#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>
#include <algorithm>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
	vector<KeyVal> vec;
    int length = content.length();
    int start = 0;
    for(int i = 0; i < length; i++){
        if((content[i] >= 'A' && content[i] <= 'Z') 
        || (content[i] >= 'a' && content[i] <= 'z')){
            continue;
        }
        else{
            if(i-1 >= 0){
                if((content[i-1] >= 'A' && content[i-1] <= 'Z') 
                || (content[i-1] >= 'a' && content[i-1] <= 'z')){
                    string word = content.substr(start, i-start);
                    KeyVal tmp;
                    tmp.key = word;
                    tmp.val = "1";
                    vec.push_back(tmp);
                }
                start = i+1;
            }
        }
    }

    return vec;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
	int num = 0;
    for(long unsigned int i = 0; i < values.size(); i++){
        num += atoi(values[i].c_str());
    }

    return std::to_string(num);
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const vector<string> &filenames);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const vector<string> &filenames)
{
	// Lab2: Your code goes here.
	string filename = filenames[index];
	std::cout << "to read  " << filenames[index] << std::endl;
	string content;
	getline(ifstream(filename), content, '\0');
	vector<KeyVal> intermediate = this->mapf(filename, content);
	std::hash<std::string> hash_fn;
	vector<KeyVal>::iterator it;
		
	string connect = "-";
	vector<vector<KeyVal>> total_kv;
	for(int i = 0; i < REDUCER_COUNT; i++){
		vector<KeyVal> tmp;
		total_kv.push_back(tmp);
	}
	for(it = intermediate.begin(); it != intermediate.end(); it++){
		int reduce_index = 0;
		string key = (*it).key;
		size_t hash = hash_fn(key);
		reduce_index = hash % REDUCER_COUNT;
		total_kv[reduce_index].push_back(*it);
	}
	for(int i = 0; i < REDUCER_COUNT; i++){
		vector<KeyVal> tmp = total_kv[i];
		string file = this->basedir + "mr-" + std::to_string(index) + connect + std::to_string(i);
		std::cout << "the intermediate file is  " << file << std::endl;
		ofstream intermediate_file(file, fstream::app);
		for(it = tmp.begin(); it != tmp.end(); it++){
			intermediate_file << (*it).key.data() << "/" << (*it).val.data() << " "; 
		}
		intermediate_file.close();
	}
	std::cout << "end MAP for   "  << index << std::endl;
}

void Worker::doReduce(int index)
{
	// Lab2: Your code goes here.
	vector<KeyVal> vec;
	for(int i = 0; i < 7; i++){
		string raw_result;
		string filename = this->basedir + "mr-" + std::to_string(i) + '-' + std::to_string(index);
		getline(ifstream(filename), raw_result, '\0');
		int size = raw_result.size();
		int start = 0;
		KeyVal keyVal;
		std::cout << filename << std::endl;
		std::cout << "raw_result.size   " << raw_result.size() << std::endl;
		for(int i = 0; i < size; i++){
			if(raw_result[i] == '/'){
				keyVal.key = raw_result.substr(start, i - start);
				start = i + 1;
				continue;
			}
			if(raw_result[i] == ' '){
				keyVal.val = raw_result.substr(start, i - start);
				start = i + 1;
				vec.push_back(keyVal);
				continue;
			}
		}
	}

	sort(vec.begin(), vec.end(),
    	[](KeyVal const & a, KeyVal const & b) {
		return a.key < b.key;
	});

	string prefix = this->basedir + "mr-out-";
	string out_filename = prefix + std::to_string(index);
	ofstream out_file(out_filename, fstream::app);
	std::cout << "vec.size()   " << vec.size() << std::endl;
	for (unsigned int i = 0; i < vec.size();) {
        unsigned int j = i + 1;
        for (; j < vec.size() && vec[j].key == vec[i].key;)
            j++;

        vector < string > values;
        for (unsigned int k = i; k < j; k++) {
            values.push_back(vec[k].val);
        }

        string output = Reduce(vec[i].key, values);
		std::cout << vec[i].key.data() << "  is   " << output.data() << std::endl;
		out_file << vec[i].key.data() << " " << output.data() << "\n";
        i = j;
    }
	out_file.close();
	std::cout << "end reduce" << std::endl;
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	std::cout << "do  submit " << std::endl;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		std::cout << "submit failed! " << std::endl;
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
	else{
		std::cout << "submit success! " << std::endl;
	}
}

void Worker::doWork()
{
	for (;;) {

		//
		// Lab2: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//
		std::cout << "begin ask fot task!" << std::endl;
		mr_protocol::AskTaskResponse reply;
		mr_protocol::status ret = this->cl->call(mr_protocol::asktask, id, reply);
		std::cout << "end ask fot task!" << std::endl;
		std::cout << reply.index << "   and the task type is  " << reply.taskType << std::endl;
		if (ret != mr_protocol::OK) {
			fprintf(stderr, "ask for task failed\n");
			exit(-1);
		}
		mr_tasktype taskType = (mr_tasktype)reply.taskType;
		std::cout << "task type is  " << reply.taskType << std::endl;
		if(reply.taskType == mr_tasktype::MAP){
			std::cout << "MAP ---  " << reply.index << std::endl;
			doMap(reply.index, reply.files);
			doSubmit(taskType, reply.index);
		}
		else{
			if(reply.taskType == mr_tasktype::REDUCE){
				std::cout << "REDUCE ---  " << reply.index << std::endl;
				doReduce(reply.index);
				doSubmit(taskType, reply.index);
			}
			else{
				std::cout << "sleep ---  "<< std::endl;
				sleep(1);
			}
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

